锁实现原理: 

<http://www.importnew.com/23511.html>

**同步代码块是使用monitorenter和monitorexit指令实现的**，同步方法（在这看不出来需要看JVM底层实现）依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。

 同步代码块：monitorenter指令插入到同步代码块的开始位置，**monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态**。

线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁； 同步方法：synchronized方法则会被翻译成普通的方法调用和返回指令如:invokevirtual、areturn指令，在VM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Klass做为锁对象。

### 1、synchronized基本原理

**多个线程是可以同时执行同一个synchronized实例方法的，只要它们访问的对象是不同的**。

**synchronized实例方法实际保护的是同一个对象的方法调用，确保同时只能有一个线程执行**。

再具体来说，synchronized实例方法保护的是**当前实例对象**，即this，this对象有一个锁和一个**等待队列**，锁只能被一个线程持有，其他试图获得同样锁的线程需要等待，执行synchronized实例方法的过程大概如下：

* 尝试获得锁，如果能够获得锁，继续下一步，否则加入等待队列，阻塞并等待唤醒；
* 执行实例方法体代码；
* 释放锁，如果等待队列上有等待的线程，从中取一个并唤醒，如果有多个等待的线程，**唤醒哪一个是不一定的，不保证公平性**；

synchronized的实际执行过程比这要复杂的多，而且Java虚拟机采用了多种优化方式以提高性能，但从概念上，我们可以这么简单理解。

当前线程不能获得锁的时候，它会加入等待队列等待，**线程的状态会变为BLOCKED**。

我们再强调下，synchronized保护的是对象而非代码，只要访问的是同一个对象的synchronized方法，即使是不同的代码，也会被同步顺序访问。

此外，需要说明的，**synchronized方法不能防止非synchronized方法被同时执行，一般在保护变量时，需要在所有访问该变量的方法上加上synchronized**。



### 2、保护实例对象和类对象

synchronized保护的是对象，对实例方法，保护的是当前实例对象this，对静态方法，保护的是哪个对象呢？是类对象，实际上，**每个对象都有一个锁和一个等待队列，类对象也不例外**。

synchronized静态方法和synchronized实例方法保护的是不同的对象，**不同的两个线程，可以同时，一个执行synchronized静态方法，另一个执行synchronized实例方法**。

### 3、特点

**可重入性**

synchronized有一个重要的特征，它是可重入的，也就是说，对同一个执行线程，它在获得了锁之后，在调用其他需要同样锁的代码时，可以直接调用，比如说，在一个synchronized实例方法内，可以直接调用其他synchronized实例方法。可重入是一个非常自然的属性，应该是很容易理解的，之所以强调，是因为并不是所有锁都是可重入的(后续章节介绍)。

可重入是通过记录锁的持有线程和持有数量来实现的，当调用被synchronized保护的代码时，检查对象是否已被锁，如果是，再检查是否被当前线程锁定，如果是，增加持有数量，如果不是被当前线程锁定，才加入等待队列，当释放锁时，减少持有数量，当数量变为0时才释放整个锁。